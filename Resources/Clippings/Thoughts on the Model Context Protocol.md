---
title: "Thoughts on the Model Context Protocol"
source: "https://www.ondr.sh/blog/thoughts-on-mcp"
author:
published:
created: 2025-03-17
description: "Thoughts on the Model Context Protocol (MCP) and how LLMs can discover and use APIs at runtime."
tags:
  - "clippings"
---
### Thoughts on MCP

Let's say you want to integrate an external API into your application. You look up the documentation, understand how the API works, and then write code against it. This happens at *design-time* — your application is now permanently coupled to that specific API. Obviously!

But LLMs *could* understand and interact with arbitrary endpoints. This suggests we could shift the burden of understanding an API from the developer to the LLM, or in other words, *from design-time to runtime*. So why can't we connect AI applications to arbitrary software while they're running?

Unfortunately, there is no consensus yet on how applications should collect API metadata, or conversely, how API providers should expose them. Simply speaking, APIs expect the caller to already know how they work. And this is starting to become a limitation.

The missing piece seems to be some kind of open meta-protocol that makes the API metadata and semantics available to the caller at runtime. The [Model Context Protocol](https://spec.modelcontextprotocol.io/specification/draft/architecture/) (MCP) by Anthropic is the most prominent one that heads in that direction. I'll simplify it drastically to bring the main point across:

Let's say we're building an LLM chat application. To make the model more useful, we'd like to give it access to our Slack channels. To do this we'll use good old function calling: We add Slack API functions to our application and then pass their metadata (along with our chat prompts) to the LLM. The model may (at some point) decide it would be useful to call one of these functions — this happens at runtime.

However, the *decision to include* the Slack API functions into our application (either by writing them ourselves or importing a library) happens at design-time:

<svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 373.703125 244" style="max-width: 373.703125px;" class="flowchart" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-diagram-1"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-diagram-1_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-diagram-1_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-diagram-1_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-diagram-1_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-diagram-1_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-diagram-1_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="Application" class="cluster"><rect height="228" width="220.1484375" y="8" x="145.5546875" style=""></rect><g transform="translate(215.07421875, 8)" class="cluster-label"><foreignObject height="24" width="81.109375"><div><span class="nodeLabel"><p>Application</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-diagram-1_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_Client1_Server_0" d="M95.555,174L99.721,174C103.888,174,112.221,174,120.555,174C128.888,174,137.221,174,145.906,174C154.59,174,163.625,174,168.143,174L172.66,174"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"></g></g></g><g class="nodes"><g transform="translate(51.77734375, 174)" id="flowchart-Client1-6" class="node default"><rect height="54" width="87.5546875" y="-27" x="-43.77734375" style="" class="basic label-container"></rect><g transform="translate(-13.77734375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="27.5546875"><div><span class="nodeLabel"><p>LLM</p></span></div></foreignObject></g></g><g transform="translate(255.62890625, 70)" id="flowchart-SlackFunctions-7" class="node default"><rect height="54" width="170.1484375" y="-27" x="-85.07421875" style="" class="basic label-container"></rect><g transform="translate(-55.07421875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="110.1484375"><div><span class="nodeLabel"><p>Slack Functions</p></span></div></foreignObject></g></g><g transform="translate(255.62890625, 174)" id="flowchart-Server-8" class="node default"><rect height="54" width="157.9375" y="-27" x="-78.96875" style="" class="basic label-container"></rect><g transform="translate(-48.96875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="97.9375"><div><span class="nodeLabel"><p>LLM interface</p></span></div></foreignObject></g></g></g></g></g></svg>

MCP adds plugin capabilities to function calling. It does so using an MCP client, which can connect to *any* arbitrary MCP server at runtime — similar to how the HTTP client inside your browser can connect to any HTTP server while the browser is running.

The difference is that HTTP servers (usually) transfer back content of a website, while MCP servers transfer back information about their functions and what they mean — so that the client can call them later.

<svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 551.2890625 244" style="max-width: 551.2890625px;" class="flowchart" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid-diagram-2"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-diagram-2_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-diagram-2_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-diagram-2_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-diagram-2_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-diagram-2_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-diagram-2_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="Application" class="cluster"><rect height="228" width="207.9375" y="8" x="145.5546875" style=""></rect><g transform="translate(208.96875, 8)" class="cluster-label"><foreignObject height="24" width="81.109375"><div><span class="nodeLabel"><p>Application</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-diagram-2_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_Client1_Server_0" d="M95.555,174L99.721,174C103.888,174,112.221,174,120.555,174C128.888,174,137.221,174,144.888,174C152.555,174,159.555,174,163.055,174L166.555,174"></path><path marker-end="url(#mermaid-diagram-2_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_Client2_Server1_1" d="M318.043,70L323.951,70C329.859,70,341.676,70,351.751,70C361.826,70,370.159,70,377.826,70C385.492,70,392.492,70,395.992,70L399.492,70"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"></g></g></g><g class="nodes"><g transform="translate(51.77734375, 174)" id="flowchart-Client1-19" class="node default"><rect height="54" width="87.5546875" y="-27" x="-43.77734375" style="" class="basic label-container"></rect><g transform="translate(-13.77734375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="27.5546875"><div><span class="nodeLabel"><p>LLM</p></span></div></foreignObject></g></g><g transform="translate(249.5234375, 70)" id="flowchart-Client2-20" class="node default"><rect height="54" width="137.0390625" y="-27" x="-68.51953125" style="" class="basic label-container"></rect><g transform="translate(-38.51953125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="77.0390625"><div><span class="nodeLabel"><p>MCP Client</p></span></div></foreignObject></g></g><g transform="translate(249.5234375, 174)" id="flowchart-Server-21" class="node default"><rect height="54" width="157.9375" y="-27" x="-78.96875" style="" class="basic label-container"></rect><g transform="translate(-48.96875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="97.9375"><div><span class="nodeLabel"><p>LLM interface</p></span></div></foreignObject></g></g><g transform="translate(473.390625, 70)" id="flowchart-Server1-25" class="node default"><rect height="54" width="139.796875" y="-27" x="-69.8984375" style="" class="basic label-container"></rect><g transform="translate(-39.8984375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="79.796875"><div><span class="nodeLabel"><p>MCP Server</p></span></div></foreignObject></g></g></g></g></g></svg>

The key insight is: *Because* this can happen at runtime, *the user* (NOT the developer) can add arbitrary functionality to the application (while the application is running — hence, runtime). And because this also works remotely, it could finally enable standardized b2ai software!

The general idea of the MCP is similar to an LSP in that messages get exchanged over a stateful, bidirectional connection. This allows for powerful features, but also makes certain things more complicated. For example, the set of actions available to a client *might depend on the state* the client is in. Similar to how the set of available links and buttons on a website depends on the state the user is in — e.g. you won't be able to click the "Go to checkout" button if your basket is empty. If you click some link, the response you get from a server ideally includes not only the new content, but the new set of actions as well.

But when an MCP client makes a function call request, the server cannot include the new set of actions in the response — the response must only include the result of the function call. MCP *does* support changing the set of available functions at runtime, but we have to send a separate notification for that. So we need to keep the bidirectional connection open on the side — and have to handle synchronization.

Now, one can argue that the MCP is designed for more interactive applications (again, like an LSP) and this is true. In practice however, most applications can be written using a simpler request-response approach, which makes the MCP niche (like Websockets vs HTTP) — not a good property to have for an emerging protocol.

The MCP has plenty of other features as well, some of them really interesting. For example *sampling*, which allows the server to "borrow" intelligence from the client — that way the server can use LLMs, but it doesn't have to implement LLM APIs. Few clients support this yet (not even Claude Desktop) and neither do servers — the concept is cool, but it seems to be hard to come up with use-cases. Maybe sampling will be a huge hit, I don't know? Predicting what users want is really hard! But every additional feature comes with structure, which makes the protocol more opinionated and thus, less flexible.

Earlier I simplified when saying "functions", but the MCP does not actually use that term. Instead, they have [tools](https://modelcontextprotocol.io/docs/concepts/tools) , [prompts](https://modelcontextprotocol.io/docs/concepts/prompts) and [resources](https://modelcontextprotocol.io/docs/concepts/resources). But in essence, all of those are functions on the server, they are just different "flavors". Each flavor has slightly different use cases and rules, e.g. prompts can only be invoked by the user, not by the LLM, tools on the other hand can't be invoked by the user. Resources can have callbacks to the client, but tools can't (except indicating progress). The input and return types are also strictly defined per flavor, e.g. you can't return a list of images from a tool, only a single image.

All that being said, I have huge incentive to see this succeed as I spent 100+ hours building my own [MCP framework](https://github.com/ondrsh/mcp4k) (and will continue to do so). I also want to give Anthropic lots of credit — they are doing pioneering work and everything is open-source!

  

But I've still been asking myself — could we come up with a better approach? I propose a *web-like* alternative in [Part 2](https://www.ondr.sh/blog/ai-web) of this post.